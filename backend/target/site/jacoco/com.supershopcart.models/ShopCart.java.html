<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ShopCart.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">supershopcart</a> &gt; <a href="index.source.html" class="el_package">com.supershopcart.models</a> &gt; <span class="el_source">ShopCart.java</span></div><h1>ShopCart.java</h1><pre class="source lang-java linenums">package com.supershopcart.models; // Ensure this matches your package structure

import com.google.cloud.firestore.annotation.DocumentId;
import com.google.cloud.firestore.annotation.ServerTimestamp;
import com.supershopcart.enums.SharePermission;
import com.supershopcart.enums.ShopCartState;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDate;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Represents a shopping cart in the system.
 * This model is designed for direct mapping to Firestore documents.
 * It stores IDs of associated shoppers, but not the full Shopper objects
 * to avoid complex nested object serialization issues in Firestore.
 */
<span class="fc" id="L21">@Setter</span>
@Getter
public class ShopCart {

    @DocumentId // Maps this field to the Firestore document ID
<span class="fc" id="L26">    private String id; // The document ID of the shop cart</span>
<span class="fc" id="L27">    private String name;</span>

    // Default to empty lists to avoid NullPointerExceptions during Firestore deserialization
<span class="fc" id="L30">    private List&lt;GroceryItem&gt; items = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L31">    private List&lt;String&gt; shopperIds = new ArrayList&lt;&gt;(); // Store only shopper IDs for association</span>
<span class="fc" id="L32">    private List&lt;SharePermissionEntry&gt; sharePermissions = new ArrayList&lt;&gt;(); // List of shopper permissions</span>

<span class="fc" id="L34">    private String dateKey; // A key for the date, perhaps for grouping/filtering</span>
<span class="fc" id="L35">    private String createdBy; // ID of the shopper who created the cart</span>
<span class="fc" id="L36">    private boolean isPublic = false; // For future public sharing feature</span>

    // Firestore will automatically populate these timestamps on creation/update
    @ServerTimestamp
<span class="fc" id="L40">    private Date createdAt;</span>
    @ServerTimestamp
<span class="fc" id="L42">    private Date lastModified;</span>

    // State management fields
<span class="fc" id="L45">    private ShopCartState state = ShopCartState.ACTIVE; // Sensible default state</span>
<span class="fc" id="L46">    private Date lastInteraction;</span>
<span class="fc" id="L47">    private Date completedAt; // When shopping trip was completed</span>
<span class="fc" id="L48">    private String currentShopper; // Who is currently shopping (if any)</span>
<span class="fc" id="L49">    private boolean isTemplate = false; // Reusable template cart</span>
<span class="fc" id="L50">    private String templateName; // Name for template carts</span>

<span class="fc" id="L52">    public ShopCart() {</span>
        // No-argument constructor required by Firestore for object mapping.
        // Fields with @DocumentId or @ServerTimestamp are handled by Firestore.
        // Lists are initialized to empty to prevent NPEs.
<span class="fc" id="L56">    }</span>

    // --- Getters and Setters ---

    // --- Helper methods to work with permissions ---

    /**
     * Retrieves the SharePermission for a given shopper ID.
     *
     * @param shopperId The ID of the shopper to check permissions for.
     * @return The SharePermission if found, otherwise null.
     */
    public SharePermission getPermissionForShopper(String shopperId) {
<span class="fc" id="L69">        return sharePermissions.stream()</span>
<span class="fc" id="L70">                .filter(entry -&gt; entry.getShopperId().equals(shopperId))</span>
<span class="fc" id="L71">                .map(SharePermissionEntry::getPermission)</span>
<span class="fc" id="L72">                .findFirst()</span>
<span class="fc" id="L73">                .orElse(null);</span>
    }

    /**
     * Adds or updates the sharing permission for a specific shopper.
     *
     * @param shopperId The ID of the shopper.
     * @param permission The permission level to set.
     */
    public void addOrUpdatePermission(String shopperId, SharePermission permission) {
        // Remove existing permission for this shopper if it exists
<span class="fc" id="L84">        sharePermissions.removeIf(entry -&gt; entry.getShopperId().equals(shopperId));</span>
        // Add new permission
<span class="fc" id="L86">        sharePermissions.add(new SharePermissionEntry(shopperId, permission));</span>
<span class="fc" id="L87">        this.updateLastInteraction(); // Update interaction time on permission change</span>
<span class="fc" id="L88">    }</span>

    /**
     * Removes the sharing permission for a specific shopper.
     *
     * @param shopperId The ID of the shopper whose permission to remove.
     * @return true if a permission was removed, false otherwise.
     */
    public boolean removePermission(String shopperId) {
<span class="fc" id="L97">        boolean removed = sharePermissions.removeIf(entry -&gt; entry.getShopperId().equals(shopperId));</span>
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">        if (removed) {</span>
<span class="fc" id="L99">            this.updateLastInteraction(); // Update interaction time if permission removed</span>
        }
<span class="fc" id="L101">        return removed;</span>
    }

    // --- State Management and Lifecycle Methods ---

    /**
     * Updates the `lastInteraction` field to the current date and time.
     * This should be called whenever the cart is modified.
     * Note: `lastModified` is handled by Firestore's `@ServerTimestamp`.
     */
    private void updateLastInteraction() {
<span class="fc" id="L112">        this.lastInteraction = new Date();</span>
<span class="fc" id="L113">    }</span>

    /**
     * Better state update logic for shared shopping, based on item purchase status.
     */
    public void updateStateBasedOnItems() {
<span class="fc bfc" id="L119" title="All 4 branches covered.">        if (items == null || items.isEmpty()) {</span>
<span class="fc" id="L120">            this.state = ShopCartState.ACTIVE;</span>
<span class="fc" id="L121">            this.updateLastInteraction();</span>
<span class="fc" id="L122">            return;</span>
        }

<span class="fc" id="L125">        boolean allPurchased = items.stream().allMatch(GroceryItem::isPurchased);</span>

        // Don't automatically mark as COMPLETED - let shoppers decide
<span class="fc bfc" id="L128" title="All 4 branches covered.">        if (allPurchased &amp;&amp; this.state == ShopCartState.ACTIVE) {</span>
<span class="fc" id="L129">            this.state = ShopCartState.SHOPPING; // Intermediate state</span>
<span class="pc bpc" id="L130" title="1 of 4 branches missed.">        } else if (!allPurchased &amp;&amp; this.state == ShopCartState.SHOPPING) {</span>
<span class="fc" id="L131">            this.state = ShopCartState.ACTIVE; // Back to active if items added</span>
        }
<span class="fc" id="L133">        this.updateLastInteraction();</span>
<span class="fc" id="L134">    }</span>

    /**
     * Marks the shopping trip as completed (manual action by a shopper).
     *
     * @param shopperId The ID of the shopper who completed the trip.
     */
    public void completeShoppingTrip(String shopperId) {
<span class="fc" id="L142">        this.state = ShopCartState.COMPLETED;</span>
<span class="fc" id="L143">        this.completedAt = new Date();</span>
<span class="fc" id="L144">        this.currentShopper = null; // No one is actively shopping anymore</span>
<span class="fc" id="L145">        this.updateLastInteraction();</span>
<span class="fc" id="L146">    }</span>

    /**
     * Starts a new shopping session from a completed cart,
     * resetting item purchase status for reuse.
     */
    public void startNewShoppingSession() {
        // Reset purchase status but keep items for reuse
<span class="fc bfc" id="L154" title="All 2 branches covered.">        if (this.items != null) {</span>
<span class="fc" id="L155">            this.items.forEach(item -&gt; item.setPurchased(false));</span>
        }
<span class="fc" id="L157">        this.state = ShopCartState.ACTIVE;</span>
<span class="fc" id="L158">        this.completedAt = null;</span>
<span class="fc" id="L159">        this.currentShopper = null;</span>
<span class="fc" id="L160">        this.updateLastInteraction();</span>
<span class="fc" id="L161">    }</span>

    /**
     * Converts the current cart into a reusable template.
     *
     * @param templateName The name for the new template.
     */
    public void convertToTemplate(String templateName) {
<span class="fc" id="L169">        this.isTemplate = true;</span>
<span class="fc" id="L170">        this.templateName = templateName;</span>
<span class="fc" id="L171">        this.state = ShopCartState.TEMPLATE;</span>
        // Reset purchase status for template
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">        if (this.items != null) {</span>
<span class="fc" id="L174">            this.items.forEach(item -&gt; item.setPurchased(false));</span>
        }
<span class="fc" id="L176">        this.updateLastInteraction();</span>
<span class="fc" id="L177">    }</span>

    /**
     * Creates a new active shopping cart based on this template cart.
     *
     * @param createdBy The ID of the shopper creating the new cart.
     * @param shopperIds A list of shopper IDs to initially share the new cart with.
     * @return A new `ShopCart` instance.
     * @throws IllegalStateException if the current cart is not a template.
     */
    public ShopCart createFromTemplate(String createdBy, List&lt;String&gt; shopperIds) {
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">        if (!this.isTemplate) {</span>
<span class="nc" id="L189">            throw new IllegalStateException(&quot;Can only create from template carts&quot;);</span>
        }

<span class="fc" id="L192">        ShopCart newCart = new ShopCart(); // Creates a new instance, ID, timestamps will be assigned by Firestore on save</span>
<span class="fc" id="L193">        newCart.setId(UUID.randomUUID().toString());</span>
<span class="fc" id="L194">        newCart.setCreatedBy(createdBy);</span>
<span class="fc" id="L195">        newCart.setShopperIds(new ArrayList&lt;&gt;(shopperIds)); // Ensure a new mutable list</span>
<span class="fc" id="L196">        newCart.setState(ShopCartState.ACTIVE); // New cart starts active</span>
<span class="fc" id="L197">        newCart.setDateKey(LocalDate.now().toString()); // Set dateKey for the new cart</span>

        // Copy items but reset purchase status
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        List&lt;GroceryItem&gt; templateItems = this.items != null ? this.items.stream()</span>
<span class="fc" id="L201">                .map(item -&gt; {</span>
<span class="fc" id="L202">                    GroceryItem newItem = new GroceryItem();</span>
<span class="fc" id="L203">                    newItem.setDesignation(item.getDesignation());</span>
<span class="fc" id="L204">                    newItem.setQuantity(item.getQuantity());</span>
<span class="fc" id="L205">                    newItem.setPurchased(false); // Always start unpurchased</span>
<span class="fc" id="L206">                    return newItem;</span>
                })
<span class="pc" id="L208">                .collect(Collectors.toList()) : new ArrayList&lt;&gt;();</span>

<span class="fc" id="L210">        newCart.setItems(templateItems);</span>
<span class="fc" id="L211">        newCart.updateLastInteraction(); // Will set lastInteraction and lastModified for the new cart</span>
<span class="fc" id="L212">        return newCart;</span>
    }

    /**
     * Checks if the cart should be moved to an archived state.
     * Criteria: Must be in COMPLETED state and completed at least 6 months ago.
     *
     * @return true if the cart should be archived, false otherwise.
     */
    public boolean shouldBeArchived() {
<span class="fc bfc" id="L222" title="All 4 branches covered.">        if (completedAt == null || state != ShopCartState.COMPLETED) {</span>
<span class="fc" id="L223">            return false;</span>
        }

<span class="fc" id="L226">        long sixMonthsInMillis = 180L * 24 * 60 * 60 * 1000L; // Approximately 6 months</span>
<span class="fc" id="L227">        long timeSinceCompletion = System.currentTimeMillis() - completedAt.getTime();</span>

<span class="fc bfc" id="L229" title="All 2 branches covered.">        return timeSinceCompletion &gt; sixMonthsInMillis;</span>
    }

    /**
     * Archives the current completed cart.
     */
    public void archive() {
<span class="fc" id="L236">        this.state = ShopCartState.ARCHIVED;</span>
<span class="fc" id="L237">        this.updateLastInteraction(); // Update interaction time when archiving</span>
        // Keep shopper associations for archived carts
<span class="fc" id="L239">    }</span>

    // --- Permission-aware Action Methods ---

    /**
     * Checks if the given shopper has permission to edit the cart.
     *
     * @param shopperId The ID of the shopper attempting to edit.
     * @return true if the shopper can edit, false otherwise.
     */
    public boolean canEdit(String shopperId) {
        // Cart creator implicitly has ADMIN permission
<span class="fc bfc" id="L251" title="All 2 branches covered.">        if (shopperId.equals(this.createdBy)) {</span>
<span class="fc" id="L252">            return true;</span>
        }
<span class="fc" id="L254">        SharePermission permission = getPermissionForShopper(shopperId);</span>
<span class="fc bfc" id="L255" title="All 4 branches covered.">        return permission == SharePermission.EDIT || permission == SharePermission.ADMIN;</span>
    }

    /**
     * Checks if the given shopper has permission to delete the cart.
     *
     * @param shopperId The ID of the shopper attempting to delete.
     * @return true if the shopper can delete, false otherwise.
     */
    public boolean canDelete(String shopperId) {
        // Only creator or ADMIN can delete
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">        if (shopperId.equals(this.createdBy)) {</span>
<span class="nc" id="L267">            return true;</span>
        }
<span class="fc" id="L269">        SharePermission permission = getPermissionForShopper(shopperId);</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">        return permission == SharePermission.ADMIN;</span>
    }

    /**
     * Checks if the given shopper has permission to mark the shopping trip as complete.
     *
     * @param shopperId The ID of the shopper attempting to complete.
     * @return true if the shopper can complete, false otherwise.
     */
    public boolean canComplete(String shopperId) {
        // Anyone with EDIT or ADMIN permission can complete shopping
<span class="nc" id="L281">        return canEdit(shopperId);</span>
    }

    // --- Standard Object Methods (equals, hashCode, toString) ---

    @Override
    public boolean equals(Object o) {
<span class="fc bfc" id="L288" title="All 2 branches covered.">        if (this == o) return true;</span>
<span class="pc bpc" id="L289" title="2 of 4 branches missed.">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L290">        ShopCart shopCart = (ShopCart) o;</span>
        // For entities mapped to Firestore documents, 'id' is typically sufficient for equality.
<span class="fc" id="L292">        return Objects.equals(id, shopCart.id);</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L297">        return Objects.hash(id);</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L302">        return &quot;ShopCart{&quot; +</span>
                &quot;id='&quot; + id + '\'' +
                &quot;, dateKey='&quot; + dateKey + '\'' +
<span class="fc bfc" id="L305" title="All 2 branches covered.">                &quot;, items=&quot; + (items != null ? items.size() : 0) + &quot; items&quot; +</span>
<span class="fc" id="L306">                &quot;, shopperIds=&quot; + shopperIds.size() + &quot; shoppers&quot; +</span>
                &quot;, createdBy='&quot; + createdBy + '\'' +
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">                &quot;, sharePermissions=&quot; + (sharePermissions != null ? sharePermissions.size() : 0) + &quot; entries&quot; +</span>
                &quot;, isPublic=&quot; + isPublic +
                &quot;, createdAt=&quot; + createdAt +
                &quot;, lastModified=&quot; + lastModified +
                &quot;, state=&quot; + state +
                &quot;, lastInteraction=&quot; + lastInteraction +
                &quot;, completedAt=&quot; + completedAt +
                &quot;, currentShopper='&quot; + currentShopper + '\'' +
                &quot;, isTemplate=&quot; + isTemplate +
                &quot;, templateName='&quot; + templateName + '\'' +
                '}';
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>